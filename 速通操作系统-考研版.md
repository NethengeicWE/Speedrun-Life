# 速通操作系统-考研版
## 前言：
* 基于王道408-2025版复习资料，**千万不要去z-library上下载盗版**
* 善用LLM
* 对本科老师的吐槽详见原版

## C1 概述：
### 1.1 定！义！
* 定义：操作系统 (Operating System，OS)是指**控制和管理**整个计算机系统的硬件与软件资源，合理地组织、**调度**计算机的工作与资源的分配，进而为用户和其他软件**提供方便接口与环境**的程序集合。操作系统是计算机系统中最基本的系统软件。
* 特征：
    1. 并发：交替运行多个程序
    1. 共享：并发程序可以使用相同资源
    1. 虚拟：物理定义 -》逻辑定义
    1. 异步：时间不确定，保证相同结果
* 目标：  
    1. 管理：进程，存储器，文件，设备
    1. 接口：命令，程序
### 1.2 发展
* 历程
    1. 裸机，所有管理由人类进行
    1. 单/多批处理系统：
        * 单：逐个执行输入程序
        * 多：并发执行缓存程序
    1. 分时操作系统：多用户，时分复用
    1. 实时操作系统：现时，紧急任务
    1. 网络/分布式操作系统：分布式，并行性
    1. 个人操作系统：win，mac，linux...

### 1.3 运行环境
* 两种不同性质的程序：内核与应用
    > 权限不同：内核可执行特权指令，更底层
    1. 时钟管理：计时的最小单位
    1. 中断：打断当前任务去执行
        * 可以操作内核，通过**自陷**实现
        * 内部中断：程序故障/终止
        * 外部中断：P/S2键盘，可屏蔽
    1. 原语：理解为原子操作，可调用的公用小程序
    1. 系统数据结构管理：进程，存储器，设备管理
    1. 系统调用syscall：设备，文件，内存，进程管理，进程调度

### 1.4 结构
* 分层法：套娃
    * 优点：易调试，易扩充，易维护
    * 缺点：层间管理不佳
* **模块化**：分叉树
    * 内聚和外耦的平衡
* 宏内核：一揽子核心
* 微内核：仅保留核心功能与服务通讯，其余功能移交用户态
    > 保留功能：进程管理，底层存储管理（比如地址变换），中断（转发）
* 外核：虚拟机特有，为虚拟机分配物理资源，避免串味
### 1.5 引导-传统的BIOS（legacy）
1. BIOS：自检，加载引导程序
1. Bootloader：前513B是MBR，负责找到活动分区，进行第二段引导
1. GRUB（Linux）：读取配置文件，调整内核参数，加载linux内核

### 1.6 虚拟机分类
1. 宿主：在windows上开vmware
1. 架空：在windows上开wsl（Hyper-V），PVZ

## C2 进程与线程
### 2.1 定义
* 进程：程序加载到内存后，在CPU执行的过程
* 进程控制块PCB：描述程序和数据的数据结构（表）
    * 存储：
        1. 进程描述信息。进程标识符PID，用户标识符UID
        1. 进程控制和管理信息
        1. 进程优先级
        1. 资源分配清单
        1. 处理机相关信息（CPU上下文）
    * 性质
        * 动态：静止的数据被cpu处理
        * 并发：多个进程存于内存中，能在一段时间内同时运行
        * 独立：进程基本单位
        * 异步：由并发导致的时间不确定
* 程序段，数据段：进程的程序和数据
* 进程状态：
    * 运行态：正在由CPU核心处理
        * 子进程：继承父进程资源，结束时释放资源
    * 就绪态：存储在运存中，随时可运行
    * 阻塞态：等待缺乏运行所需的资源传达，所有资源齐全后进入就绪态
    * 终止态：不再运行，释放占用资源，结束子进程
    * 创建态：正在创建进程
        1. 分配进程标识号，创建PCB
        1. 分配资源：内存，文件，io资源，cpu时间等
        1. 初始化PCB：cpu状态信息和控制信息
* 进程通讯：
    * 共享存储：划分可共享的内存空间，需要同步互斥工具
    * 消息传递：利用操作系统提供的消息传递方法实现通信，分为直接（直达）/间接（转接）
    * 管道通信：特殊的共享文件：一端写一端出，单向传递。在linux中常用，一般会限制大小，如果管道为空则读取命令会导致进程进入阻塞。
* 进程和线程的区别：**一个进程可以包含多个线程**
    * 进程：操作系统层级的程序管理，拥有独立的地址空间，比较庞大
    * 线程：CPU层级的任务管理，共享地址空间，更加灵活，系统线程难以终止      
    线程也有与PCB类似的TCB：标识符，寄存器，优先级，存储区，堆栈指针  
    > * 进程与线程
    > 进程就像是一个公司，每个公司有独立的办公空间（地址空间）和资源（如资金、设备等）。    
    > 线程就像是公司中的员工，员工共享公司的资源，但每个员工有自己的工作任务（栈和寄存器状态）。    
    > * 用户空间与内核空间:  
    > 用户空间就像是普通员工的办公区，员工可以自由工作，但不能直接操作公司的核心设备（硬件资源）。  
    > 内核空间就像是管理层的办公区，管理层可以直接操作公司的核心设备，管理整个公司的运作。
* 线程实现方式：权限不同——用户线程/内核线程
    * 用户级：内核进程使用用户空间线程库，无需模式切换，单独设置进程调度，不依赖操作系统，但一个线程阻塞会影响到整个进程
    * 内核级：小，切换快，内核支持运行，支持多线程，但是同进程下的线程切换开销大
    * 组合方式：综合实现，一个内核线程通过时分复用控制多个用户线程（后文提及）
* 多线程模型：
    * 一对多：一内核多用户，调度管理在用户，但是访问内核时会出现阻塞
    * 一对一：一内核一用户，调度在内核，无阻塞，高并发，但是内核开销大
    * 多对多：少量内核多个用户：综合上述优点
### 2.2 调度
* 定义：将算法高效分配给CPU进行运行
* 调度层次
    1. 高级调度（作业调度）：内存与存储
    1. 中级调度（内存调度）：将暂时不运行的进程挂起，具备运行条件且内存有空闲时再调入内存
    1. 低级调度（进程调度）：从就绪序列中选取一个进程分配给cpu运行
* 调度器：
    * 排队器：就绪进程通过排队器插入就绪队列
    * 分配器：从队列中取出进程，分配给CPU
    * 上下文切换器：切换进程---保存进程上下文至PCB，装入新的上下文
        * 装填寄存器及其费时，故设计两套计时器：内核与用户
* 调度操作：
    * 时机：新线程创建，进程结束/终止，进程被阻塞，中断。  
    高优先级强行剥夺，时间片耗尽
    * 不能调度：中断处理，完全屏蔽中断的原子操作
    * 方式：抢占/非抢占调度
    * 闲逛进程：就绪队列为空时运行
    * 用户/内核进程：
        * 用户进程：对内核透明，内核选择一个进程，给与时间控制，由调度程序决定。  
        线程切换是在同一进程中。仅需少量机器指令
        * 内核进程：选择一个特定线程执行，给予时间片，时间片结束强行剥夺  
        完整的上下文切换，修改内存块和高速缓存，详见[速通计组-考研版](./速通计组-考研版.md#35-高速缓存)
    * 目标：多种标准
        > **我爸得了M⬆ V➡P⬇！**
        * CPU利用率：有效工作时间/有效+空闲时间
        * 系统吞吐量：单位时间完成的作业数量
        * 周转时间：作业完成时间-作业提交时间
            * 平均周转时间：多个作业周转时间平均值
            * 加权平均周转时间：权重为 $\frac{周转时间}{运行时间}$
        * 等待时间：进程等待被执行的时间
        * 响应时间：用户提交请求到系统响应的时间
* 进程切换-上下文切换：
    * 定义：保存当前进程状态，恢复另一个进程状态
    * 流程：
        1. 挂起一个进程，CPU上下文保存到PCB
        1. 进程PCB移入其他等待队列
        1. 选择一个程序执行，更新PCB
        1. 恢复新进程的上下文
        1. 跳转到新进程PCB的程序计数器继续执行
    * 消耗：使用可观的CPU时间，如果设置多个寄存器则只用改变指针
    * 模式切换：CPU在运行内核态和用户态线程的切换
* 典型调度算法：
    * 先来先服务FCFS：不可剥夺，公平作业
        * 等待时间不佳
    * 短作业有限SJF：优先运行-运行时间最短的作业
        * 对长作业不公，可能会饿死
    * 高响应比调度：综合上述两种操作，优先执行响应比高的作业
        * 响应比：$R_p = \frac{等待时间+要求服务时间}{要求服务时间}$
    * 优先级调度：根据人工设定的优先级，高优先级优先调度
        > 回想缺氧的调度，合理调度能最大化生产效率，减少周转时间
        * 适用于存储调度和进程调度
        * 抢占/非抢占：等待队列中出现了比正在执行的作业更高的优先级，是否立即切换
        * 动态/静态优先级：创建进程时确定/随进程执行或等待时间
        * IO型/计算型：io设备的处理速度比CPU慢，高优先级的io进程能尽快使得io设备工作
    * 时间片轮转：分时系统
        * 就绪进程按照FCFS策略排序，每个就绪进程都能分得一定时间执行
        * 频繁的上下文切换，小号新年
    * 多级队列调度：多个就绪队列，根据类型和性质分配，可执行不同的调度算法
    * 多级反馈队列调度：时间片+优先级调度
        * 多个优先级不同，时间片不同的FCFS队列
        * 如果未能在时间片内完成，调入下一级队列
        * CPU优先运行高优先级队列

### 2.3 同步与互斥
* 基本概念：
    * 缘由：并发进程有着不同的制约关系，存在只能一个人用的临界资源
    * 同步：多个进程间的相互合作
    * 互斥：临界资源被使用时阻止其他人的访问
    * 准则：空闲让进，忙则等待，有限等待，让权等待
    > 顾头不顾尾：解决了资源乱用的情况，但带来的阻塞可能导致严重问题
* 软件实现：
    * 单标志法：标准的茅屎坑位，单向锁，一眼丁真
    * 双标志先检查：标准的茅屎坑位，外面的人会敲门
    * 双标志后检查：如果有人敲门那么优先让给外面的人
    * Peterson：坑位外面一群人
* 硬件实现：
    * 中断屏蔽：进入临界区关闭中断，避免不存在的逻辑
    * 硬件TestAndSend：原子操作，读出标志并设置为真
    * 硬件Swap：交换两字节内容
* 互斥锁：上锁，解锁，检测
* 信号量：多个厕所坑位，有就上；有时会要求把学生证贴在外面  
实现进程同步与资源互斥
* 经典问题
    1. 生产-消费者问题：一个进程取出，一个进程放入
    1. 读者-写者问题：可以并发读取，但写入必须独占
    1. 哲学家进餐问题：临界资源被两个进程争夺，进程需要两个不同的临界资源
    1. 吸烟者问题
* 管程：进程同步工具，无需手动实现互斥锁
    * 组成：名称，数据结构，操作方法，初始值
    * 多条阻塞队列，由阻塞原因划分

### 2.4 死锁
* 定义：多个进程竞争资源导致都被阻塞
    * 必要条件：互斥资源，不可剥夺，保持请求，循环等待
* 饥饿：有限资源的分配策略导致某些进程的等待时间过长
* 处理策略
    1. 预防：设置限制条件破坏必要条件
        * 一般不能破坏互斥
        * 剥夺会造成部分工作无效，而且资源装填和卸载耗时
        * 一次性申请全部资源/释放才能申请
        * 资源编号，只能申请编号更小的
    1. 避免：资源分配防止进入不安全状态
        * 银行家算法：每次分配预测是否进入不安全状态  
        维护三个矩阵：已分配，需求，可用；每次申请估计是否能还回
    1. 检测：允许死锁，检测并解除
        * 资源分配图：消去不阻塞且不孤立进程的请求边和分配边，如果存在不可消去的，则死锁
        * 解除：杀死进程，回滚，强夺


## C3 内存管理
### 3.1 概念
* 定义：对内存的划分和动态分配
* 功能：内存空间的分配与回收，地址转换，内存扩充，内存共享，存储保护
* 程序装入：
    1. 程序编译与链接：转为机器码，连接所需要的库函数
        * 静态链接：转为完整模块，需要修改相对地址
        * 装入时动态链接：装入内存时候再链接
        * 运行时动态链接：执行时再链接，节省内存空间
    1. 装入：存储载入内存
        * 绝对装入：程序指定载入内存的固定位置
        * 可重定位装入：可以指定偏移
        * 动态运行装入：直到执行程序时才转换地址，需要重定位寄存器
* 逻辑地址：编译后程序内部从0开始编址，称作相对地址（逻辑地址）  
* 物理地址：对应物理世界的地址，逻辑地址通过内存管理部件MMU转换为物理地址进行访存
* 地址映射：如果（逻辑页号+起始页表）不越界，则在内存的页表查询物理页号，页内偏移查询具体数据
* 进程在内存中：
    1. 代码段：只读，可共享
    1. 数据段：全局变量和静态变量
    1. 进程控制块PCB
    1. 堆：动态分配的变量，通过malloc向高地址分配空间
    1. 栈：函数调用：从用户空间向低地址增长（有限容量）
* 内存保护：进程使用单独的内存空间，进程间不得互相干扰  
    1. CPU中设置一对上下限寄存器存储进程空间范围，每次访存检查
    1. 基地址寄存器和界地址寄存器：检查后再映射地址
* 内存共享：只共享只读区域，如果需要修改则复制到自己的内存空间中再修改
* 内存管理与回收：
    * 单一连续分配：系统区，用户区。早期使用
    * 固定分区分配：划分用户空间为若干固定大小的分区，分区只装入一个作业；分区使用表记录使用情况
    * 动态分区分配：根据需求动态分配内存。会积累小内存块，需要动态重定位寄存器整理
        * 分配/回收方法-空闲分区链表：  
        首次适应：第一个满足大小的分区；低地址产生碎片  
        临近适应：从上次结束的地方方式查找；高地址没有大空闲  
        最佳适应：最小的空闲分区；最多的碎片产生  
        醉花适应：最大的空闲分区；迅速消耗大空闲
        * 使用索引搜索适应大内存：以大小分类的多个空闲分区链表  
        快速适应：在能容纳的最小链表中取出第一块；回收分区的开销较大  
        伙伴系统：规定分区大小为2的幂次，如果不能在最小链表中找到空闲表，则在次小的链表中分配，一半用于作业，另一半用于分配
        * 哈希算法：根据链表分布规律建立哈希表
    * 离散分配-页式存储：将内存空间分为固定大小的分区称为页框；进程的逻辑地址空间按页寻找；产生极小的业内碎片
        * 页框号（物理地址），页号（逻辑地址）
        * 地址结构：页号+业内偏移
        * 页表：页号到物理页号的地址映射
        * 快表TLB：在缓存中的快速页表，不需要越界检验；如果未命中，则载入页表
        * 多级页表：对页表再分类，可以只装载需要的二级页表加快查询
    * 分段：分页是基于硬件的，对用户透明；分段面向用户以满足其需求
        * 将用户进程的逻辑地址空间划分为大小不同的段，如程序段，栈段，数据段
        * 结构：段号，段内偏移
        * 段表：段号映射到基址和段长
        * 地址映射：类似于页的地址变换
        * 共享与保护：共享运行代码；存取控制保护与地址越界保护 
    * 段页式存储管理：地址空间被分成若干逻辑段，每段分成固定大小的页
        * 逻辑地址：段号，页号偏移，页内偏移
        * 段号查页表，页表查主存

### 3.2 虚拟内存
* 局部性原理：执行的指令会集中执行；访问的存储单元也会集中访问
* 虚拟存储器：不需要将程序完全装入内存，不常访问的存在存储中，有需要的时候再与内存中的交换
* 只使用离散分配的内存管理
* 请求分页存储管理：在基本分页基础上添加请求调页和页面置换
    * 页表新增字段：状态位-是否调入内存，访问字段-最近访问次数/最近访问时间，修改位-是否修改，外存地址（一般为块号）
    * 如果页面不在内存时产生缺页中断，把需要的页载入内存，如果替换的页被修改，需要先写回再载入
    * 查快表，查页表，（快表修改），（缺页中断）访存
    * 驻留集：进程分配到的内存页，肯定不能塞入所有进程内容
        * 固定分配局部置换：建立起（平均分配，按比例，优先权）设定页框，进程运行期间不改变大小
        * 可变分配全局置换：进程的物理页框数量可动态调整，从其他进程划分
        * 可变分配局部置换：同上，但是只在进程内部置换
    * 调入时机：预先调入相邻页/根据请求调入
    * 调入来源：请求分页的外存分为离散文件区和连续交换区  
    文件区到交换区（写）/文件区直接到内存（读）/前两者+不从交换区写回文件区
    * 置换算法：等权重时按先进先出算
        * OPT最佳置换：**以后**永不使用（预测未来），因为无法实现所以近似为最长时间不再访问
        * FIFO先进先出：字面意义
        * LRU最近最久未使用：淘汰**上一次**访问时间最长（根据历史）
        * CLOCK时钟置换：物理页框形成循环链表，设置标记位；缺页中断时循环指针直到轮询标记位为0，期间标记位为1置0
        * 改进型CLOCK：增加修改位，置换双0标记位的页面，期间的标记改变先把标记位置0再修改位置0
    * 抖动：刚换出的页面马上换入，刚换入的马上换出；  
    解决办法：提高物理块的分配
    * 内存映射文件：将可共享的内存空间映射到虚拟地址
    * 性能分析-缺页率：页大小，置换算法，写回（可以缓存，一起写回）
    * 地址翻译：
        * 系统环境：4路组相连TLB与16条目，dataCache；虚拟地址14位，物理地址12位，64B页面，
* 请求分段存储管理,请求段页式存储管理

## C4 文件管理
### 4.1 文件系统基础
* 文件：信息集合；用户输入输出的基本单位；数据结构
* 属性：名称，类型，创建者，所有者，位置，大小，保护，创建&最后修改&最后读取时间
* 分类：系统/用户/库，源/目标/可执行，读/写/执行，普通/目录/特殊
* 文件控制块FCB：文件名，类型，权限，大小，数据块指针  
    必须连续存放
* 索引节点：仅包括文件名和数据块指针，加快搜索速度
    * 磁盘索引节点-存放在磁盘上的索引节点：主标识符，文件类型，存取权限，物理地址（指出盘块编号）文件长度，被指向次数，存取时间
    * 内存索引节点：存放在内存时的索引节点，随文件载入  
    新增索引节点号，状态，访问次数，逻辑设备号，链接指针
* 基本操作：
    * 创建：分配外存空间，创建目录项
    * 删除：删除目录项和FCB，释放占用空间
    * 读取：查找目录项，获得外存地址
    * 写入：查找目录项，利用目录项的写指针进行操作
    * 打开：
    * 关闭
* 文件保护：阻止文件破坏或被未允许的修改，可通过口令保护，加密保护和访问控制
    * 访问类型：读，写，执行，添加，删除，列表清单；  
    高层功能包括重命名，复制，编辑等
    * 访问控制：访问控制板Access-Control List
* 逻辑结构
    * 无结构文件：流式文件，适合源文件，可执行代码等。不适合查找
    * 有结构文件：一个以上的由数据项组成的记录。分为定长和变长
        * 顺序：时间串结构，关键字顺序结构（可二分法查找）；
        * 索引：定长可以直接计算出地址，变长需要遍历或者建立索引表
        * 索引顺序文件：带索引表的顺序文件，索引表记录查找用的键值和对应的逻辑地址
        * 直接文件：给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址
* 物理结构：文件数据在物理存储设备上如何分布和组织  
    以磁盘块为基础单位分配
    * 连续分配：每个文件在磁盘上占用一组连续的块。  
    访问快速，但会产生碎片，需要知道文件长度，不能扩展
    * 链接分配：离散分配
        * 隐式链接：目录项存放第一块和最后一块的指针，磁盘块分散在磁盘的任何位置，每一个盘块记录下一个盘块的地址  
        易于扩展和修改；只能顺序访问，访问速度较慢，稳定性不佳  
        可以将盘块组成簇用于查找，加速查找和访问速度，但增加碎片
        * 显式链接：单独记录一张链接表，称作文件分配表FAT   
        需要占用额外的空间
    * 索引分配：链接表作为块存储，FCB指向该块。可以使用多级索引  
    加快大型文件查找，但不适合小文件
    * 混合索引：小文件直接寻址，一般使用一级索引，大型使用二级索引
### 4.2 目录
* 定义：FCB的有序集合  
面向用户需要管理名称（不得重复）和效率；多用户需要访问控制
* 结构：
    * 单级目录：只有一张目录表，每个文件（FCB）占用一个目录项
    * 两级目录：目录表分为主文件目录和用户文件目录  
    主文件目录记录用户，用户记录个人文件；但依旧不能分类
    * 树形目录结构：多级目录，被大部分操作系统使用
    * 无环目录结构：允许共享子目录和文件
* 操作：搜索，创建文件/目录，删除文件/目录，移动目录，显示目录，修改目录
* 实现：
    * 线性列表：文件名和数据块指针的线性列表
    * 哈希表：通过文件名得到一个值和指向线性列表的指针
* 共享：
    * 硬链接：基于索引节点实现，文件的物理地址与属性存放在索引节点中，目录存放文件名和索引节点指针  
    删除只扇区指针，节点的引用次数-1
    * 软链接：新建一个LINK类型文件，指向原文件
### 4.3 文件系统
* 提供高效便捷的磁盘访问
    * IO控制层：设备驱动与中断程序
    * 基本文件系统：读写物理块
    * 文件组织模块
    * 逻辑文件系统
* 分区：多数磁盘被划分一个或多个分区，拥有一个独立的文件系统
    * 主引导记录MBR：0号扇区，记录每个分区的起始与结束地址。  
    启动计算机时BIOS读取MBR，确定活动分区，读入引导块
    * 引导块：启动分区的操作系统
    * 超级块：包含文件系统的关键信息，如块的数量大小，空闲数量，FCB
    * 空闲块信息：
* 外存空间管理：
    * 卷：包含文件系统的分区，范围可以超越物理限制  
    文件区和目录区分离；需要初始化
    * 空闲表法：记录空闲块起始号和连续数
        * 分配：类似于内存的动态分配如首次适应和最佳适应
        * 释放：类似于内存回收，需要合并空闲区域
    * 空闲链表法：
        * 空闲盘块：每个空闲盘块记录下一个空闲盘块的指针  
        易于分配，缺点是每次分配可能需要重复操作，这个链会很长
        * 空闲盘区链：每个空闲盘区块记录下一个空闲盘块区的指针和本盘区的长度  
        不易分配，但效率更高
    * 位视图法：一张用二进制记录盘块使用情况的表  
    容易找到空块，但是不适合大容量磁盘
    * 成组链接法-套娃式空闲盘区链：维护一个栈，存放在超级块中，UNIX使用  
    每个划分的空闲盘区有最大值，第一个空闲盘块记录下一组空闲盘区和当下的空闲盘块  
    分配与回收优先使用栈内块，栈空则加载空闲盘区，栈满则挂到空闲区链中
* 虚拟文件系统：屏蔽不同文件系统的差异与操作细节，向上为用户提供文件操作的统一接口
    * 超级块：已挂载的特定文件系统
    * 索引节点：
    * 目录项对象
    * 文件对象
* 文件系统挂载
    * windows：维护一个扩展的二级目录结构。使用驱动器字母表示设备和卷
    * UNIX：根文件系统，所有文件系统必须挂载到根文件系统才能访问。  
    一个设备可以有多个挂载点，但一个挂载点只对应一个设备

## C5 IO管理
### 5.1 概述
* 分类：
    * 按基础单位：
        * 块设备：以数据块为单位，主要是磁盘，可寻址，常用DMA
        * 字符设备：以字符为单位，顺序读取，使用缓冲区
    * 按速率：低速（KB）中速（MB）高速（G）
    * 按模式：阻塞/非阻塞
    * 使用特性：存储，交互式
    * 共享属性：独占，共享，虚拟
* IO接口：CPU与设备的接口  
    功能：接收识别命令，数据交换，标识报告设备状态，地址识别，数据缓冲，差错控制
    > CPU只负责执行指令，IO负责传递数据，这包括PCIe和内存控制器
* IO端口：设备控制器直接访问的寄存器，数据/状态/控制寄存器
    * 端口地址：供CPU访问；根据与主存地址的关系分为独立编址和统一编址（内存映射IO）
* IO控制方式
    * 程序直接控制：又称程序轮询-一直问IO控制器有没有准备好的数据
    * 中断驱动：IO控制器准备好数据就向CPU发出中断信号
        > > 经典例子：PS/2键鼠
    * DMA直接存储器存取：不需要CPU参与传递数据块
        * DMA控制器维护4类寄存器：命令/状态寄存器，内存地址寄存器，数据寄存器，数据计数器
        * 接收到DMA请求后向DMA控制器发出命令，设置MAR和DC，然后由DMA代管内存载入
        >  >谁把我的AMD插反了？！
    * 通道控制方式：
* IO层次结构：向下请求，向上应答
    * 用户层软件：提供标准API
    * 设备独立性软件：内核中通用设备管理层，解析用户命令，发配给指定设备
    * 设备驱动程序：内核中直接操作硬件的模块
    * 中断处理程序：直接与硬件交互
### 5.2 设备独立性软件  
IO层最高层软件，与设备驱动的界限模糊
* 硬盘高速缓存：提高磁盘的IO速度
* 缓冲区：
    * 目的：缓解CPU速度和IO速度的不匹配导致的中断频率，提高并行度，数据粒度
    * 实现方法：硬件缓冲区，内存空间
        * 单缓冲：一个缓冲区，区满交给进程处理，输入和处理可以同时进行，时间max（输入，处理）+传输  
        两台机器间如果都使用单缓冲则只能单工
        * 双缓冲：两个缓冲区，一个填充数据一个交由进程处理，处理完毕后两个缓冲区互换，时间max（传输+处理，输入）
        * 循环缓冲：多个缓冲区组成循环链，适用于速度差距过大的情况。两个指针一入一出
        * 缓冲池：管理多个缓冲区，可供多个进程共享；4种工作方式：
* 与高速缓存的区别：前者只是副本，后者是临时中转
* 设备分配：根据用户IO请求分配设备，尽量使用且避免死锁
    * 数据结构
        * 设备控制表DCT：设备类型，设备标识符，设备转胎，  
        指向控制器指针：每个设备由一个控制器控制  
        重复执行次数：重复执行次数达到规定值仍不成功时认为io失败
        设备队列队首指针：等待该设备的进程队列
        * 控制器控制表COCT：控制器状态
        * 通道控制表CHCT：通道状态
        * 系统设备表SDT：记录所有物理设备的情况
    * 分配因素
        * 固有属性；独占，共享，虚拟内存
        * 分配算法：FCFS，加权FCFS
        * 安全性：是否阻塞
    * 分配步骤：查询设备，查询控制器和队列状态
    * 逻辑设备表LUT：逻辑设备名，物理设备名，驱动程序入口地址；全局（系统）设置或用户设置
    * SPOOLing技术（假脱机）：针对独占设备的并发问题，由守护进程管理任务缓冲区队列