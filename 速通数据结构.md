## C1 绪论
## C3 栈，队列，线性表
### 栈
只能从一边进入的捅
* 操作：放入，取出，查看第一个元素，元素数量
* 形式
### 队列
只允许一边进入，一边出的管子
* 操作：放入，取出，查看第一个元素，元素数量
## C5 二叉树
* 基础知识：
    * 度：一个节点挂载的分支节点，对于树的度取决于子节点最大度
    * 高度/深度：我也不知道怎么说，画个图就知到了
    * 有序&无序：左右节点能否互换
    * 森林：若干互不相交的树的集合
* 分类  
    * 满二叉：所有节点挂满
    * 完全二叉：顺序存储没有分散的空节点
    * 真二叉：没有单分支节点
    * 平衡二叉：任意节点的左右子树的深度差不超过1
    * 二叉排序树：用于查询的树，大幅降低时间复杂度
...
* 顺序存储：按宽度优先遍历的顺序，如果没有节点则设置为0或其他约定的标志
* 链式存储：带有指向孩子节点的指针
* 二叉树遍历：
    * 深度优先：先序，中序，后序。根据访问根节点的顺序命名
    > 有递归和非递归的算法，后者使用栈（模拟递归）
* 二叉树构建：必须有中序，除非是真二叉树
    * 根据遍历结果：前/后序确定根节点划分左右，迭代此操作
* 树的表示方法
    * 双亲表示法：每个节点记录父节点的数组位置
    * 孩子表示法：每个节点的孩子作为线性表
    * 孩子兄弟表示法：二叉树表示法
* 树转为二叉树：对于每个节点，第一个子节点做左孩子，下一个兄弟节点做右孩子
* 二叉树转树：反向操作
* 哈夫曼树：加权路径最短的二叉树
    * 加权计算：深度*节点权重
    * 步骤：挂上权重最小的节点，然后作为新树的右半部分，左半部分挂剩下节点中的最小
    * 哈夫曼编码：字符的编码长度不一，频率高的编码长度更小。
        > 左0右1
* 并查集：相似元素（由其他因素决定）化为兄弟节点
## C6 图
* 什么是图：![alt text](image\image.png)
    * 有向/无向图：有没有方向限制
    * 简单/多重图：后者存在重复边和自循环
    * 完全图：全连接的无向图
    * 子图：选取部分顶点和部分边组成的新图
    * 联通：任意两个顶点之间都有路径相连
        * 极大连通子图：再加入原图中任何一个其他顶点，子图不满足全联通
* 存储方式
    * 邻接矩阵：可以记录是否相连和连接权重
    * 邻接表：每个节点记录连接的相邻节点，数据结构为单向链表
        * 十字链表
* 基础操作：
    ```c
    ```
    * 遍历算法：栈/队列，访问后的节点增加标记
* 最小生成树：
    * prim算法：随机起点，每次连接已知的最便宜路线
    * Kruskal算法：每次连接全局最便宜路线，直至所有节点联通
    * Dijkstra算法：计算节点间的最短路径
        * 贪心算法&决策回溯