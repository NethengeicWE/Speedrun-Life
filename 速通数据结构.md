## C1 绪论
## C3 栈，队列，线性表
### 栈
只能从一边进入的捅
* 操作：放入，取出，查看第一个元素，元素数量
* 形式
### 队列
只允许一边进入，一边出的管子
* 操作：放入，取出，查看第一个元素，元素数量
## C4 串
一般指字符串
* KMP匹配算法：构建查找序列的部分匹配表（理解为特征表）
    * 部分匹配表记录字符串的重复情况：每重复一次+1，如果变化置0
    * 如果匹配失败，则查找序列指针根据KMP表跳转而不是0（一般匹配）
    * 时间复杂度：O（m+n）
## C5 二叉树
* 基础知识：
    * 度：一个节点挂载的分支节点，对于树的度取决于子节点最大度
    * 高度/深度：我也不知道怎么说，画个图就知到了
    * 有序&无序：左右节点能否互换
    * 森林：若干互不相交的树的集合
* 分类  
    * 满二叉：所有节点挂满
    * 完全二叉：顺序存储没有分散的空节点
    * 真二叉：没有单分支节点
    * 平衡二叉：任意节点的左右子树的深度差不超过1
    * 二叉排序树：用于查询的树，大幅降低时间复杂度
...
* 顺序存储：按宽度优先遍历的顺序，如果没有节点则设置为0或其他约定的标志
* 链式存储：带有指向孩子节点的指针
* 二叉树遍历：
    * 深度优先：先序，中序，后序。根据访问根节点的顺序命名
    > 有递归和非递归的算法，后者使用栈（模拟递归）
* 二叉树构建：必须有中序，除非是真二叉树
    * 根据遍历结果：前/后序确定根节点划分左右，迭代此操作
* 树的表示方法
    * 双亲表示法：每个节点记录父节点的数组位置
    * 孩子表示法：每个节点的孩子作为线性表
    * 孩子兄弟表示法：二叉树表示法
* 树转为二叉树：对于每个节点，第一个子节点做左孩子，下一个兄弟节点做右孩子
* 二叉树转树：反向操作
* 哈夫曼树：加权路径最短的二叉树
    * 加权计算：深度*节点权重
    * 步骤：挂上权重最小的节点，然后作为新树的右半部分，左半部分挂剩下节点中的最小
    * 哈夫曼编码：字符的编码长度不一，频率高的编码长度更小。
        > 左0右1
* 并查集：相似元素（由其他因素决定）化为兄弟节点
## C6 图
* 什么是图：![alt text](image\image.png)
    * 有向/无向图：有没有方向限制
    * 简单/多重图：后者存在重复边和自循环
    * 完全图：全连接的无向图
    * 子图：选取部分顶点和部分边组成的新图
    * 联通：任意两个顶点之间都有路径相连
        * 极大连通子图：再加入原图中任何一个其他顶点，子图不满足全联通
    * 有向无环图DAG：适合构建公式
        * AOV：DAG的基础上定义边关系是先后的依赖关系
    * 拓扑排序：DAG的基础上要求不存在重复顶点和始终只有单向路径
        * 适合构建编译树
        * 每访问一个节点删除以该节点起始的有向边
    * 关键路径：即最长路径，决定了项目的完成速度
        * 计算方法：根据拓扑排序计算每个节点的最短开始时间和最早开始时间  
        不高于1则为关键路径
* 存储方式
    * 邻接矩阵：可以记录是否相连和连接权重
    * 邻接表：每个节点记录连接的相邻节点，数据结构为单向链表
        * 十字链表
* 基础操作：
    ```c
    ```
    * 遍历算法：栈/队列，访问后的节点增加标记
        * 遍历算法生成树，若存在未联通需另作处理
* 最小生成树：
    * prim算法：随机起点，每次连接已知的最便宜路线
    * Kruskal算法：每次连接全局最便宜路线，直至所有节点联通
    * Dijkstra算法：计算节点间的最短路径
        * 贪心算法&决策回溯

## C7 查找
* 顺序查找：默认
* 折半查找：有点像二叉树
* 分块查找：手动分类
---
* 树型查找：二叉排序树
* 平衡二叉树：子树高度不高于1，控制复杂度
    * 插入/删除：先根据一般二叉树的规则插入/删除，更新平衡
    * 平衡调整：LL/RR-叶子节点成为父节点的兄弟，LR/RL-转换为LL和RR问题
    * 红黑树：放款平衡条件，减少调整次数
        * 一定为黑：根节点，叶节点
        * 节点可能为红，也可能为黑。但一定不会有兄弟节点均红
        * 任意节点访问叶节点时经历的黑节点数量一定相同
        * 旋转操作-不影响中序遍历：保证左子树不低于右子树
            节点左旋：右节点代替节点，原节点作左节点。其他节点保证左小右大  
                你可以理解为把A往左下扯
            ```
            旋转前：            旋转后：
            |                  |
            A                  B
             \                / \
              B (右儿子)      A   D
             / \              \
            C   D              C
            ```
            节点右旋：左节点代替节点，原节点左右节点。其他节点保证左小右大  
                你可以理解为把D往右下扯
            ```
            旋转前：            旋转后：    
                |              |   
                D              B
               /              / \
              B (左儿子)      A   D
             / \            /
            A   C          C
            ```
* B树：完全平衡的多路查找树，最大路记作m
    * 特点：节点可以存在少于子节点的有序索引  
    节点索引数由深度决定，深度会影响磁盘存取次数
    * 插入：可能会导致节点溢出，这会导致分裂-中间键提拔为索引，其余作子节点
    * 删除：可能会导致子节点过少，如果从兄弟借不够就
* B+树：B树的基础上叶子节点形成链表，叶子节点
* Hash散列：哈希函数将任意键均匀映射为固定大小的哈希值
    * 常用函数：线性，除余
        * 数字分析法：常用数字位置
        * 平方取中：关键字平方值的中间位
    * 冲突处理：
        * 开放定址：$H(key)=(H(key)+d_i) % m$
            * m：散列表表长
            * d_i：多种方式：n，±n²，i*二次哈希，伪随机
        * 拉链法：形成链表
    * 散列查找：对比键值，如果找不到就按冲突处理重新计算
## C8 排序
* 稳定性：关键字相同时排序算法是否影响顺序
* 插入排序：从未排序部分取出第一个元素，插入到已排序部分的正确位置
    * 直接排序：顺序查找
    * 折半插入：二分查找
    * 希尔排序：分成多个小组进行直接排序，逐步缩小组数
* 交换排序：检查相邻元素，逆序则交换
    * 冒泡排序：交换排序直至无逆序
    * 快速排序：每次取第一个元素做基准，比他小的放左边，比他大的放右边。递归执行
        * 实现方法：两个指针，一个指针从头开始扫描比基准大的，一个指针从尾扫描比基准小的。  
        符合目标就填入空缺，直到指针相遇
* 选择排序：寻找未排序列表中最小
    * 堆排序-使用堆数据结构：父节点大于子节点，左节点大于右节点
    * 用宽度优先展开

* 归并排序：合并有序表，n路代表一次处理多次的列表  
合并方法：两个列表先合并至临时数组，每次比对两列表同位置的数字，小的放入其中一个表；任意一个读完，另一边剩下的直接放入该表
* 基数排序：逐步按个位，十位，百位排序
* 复杂度：

| 排序种类       | 最好情况时间复杂度 | 平均情况时间复杂度 | 最坏情况时间复杂度 | 空间复杂度 | 是否稳定 |
|----------------|--------------------|---------------------|---------------------|------------|-----------|
| 直接插入排序   | O(n)               | O(n²)               | O(n²)               | O(1)       | 是        |
| 冒泡排序       | O(n)               | O(n²)               | O(n²)               | O(1)       | 是        |
| 简单选择排序   | O(n²)              | O(n²)               | O(n²)               | O(1)       | 否        |
| 希尔排序       | O(n)               | O(n^1.3) ~ O(n^1.5)   | O(n²)               | O(1)       | 否        |
| 快速排序       | O(n log n)         | O(n log n)          | O(n²)               | O(log n)   | 否        |
| 堆排序         | O(n log n)         | O(n log n)          | O(n log n)          | O(1)       | 否        |
| 二路归并排序   | O(n log n)         | O(n log n)          | O(n log n)          | O(n)       | 是        |
| 基数排序       | O(d(n + r))        | O(d(n + r))         | O(d(n + r))         | O(r)       | 是        |

* 外部排序问题：元素过大，无法存入主存
    * 常用办法：归并排序
    * 多路归并问题：提升k减少归并次数，但内部归并时间更长
        * 败者树：叶节点对应每一路查找，整棵树就是一个晋级赛
        * 最佳归并树：优先合并总代价小的