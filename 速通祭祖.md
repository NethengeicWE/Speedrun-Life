# 计算机组成速通
## 前言
* 计组老师成功引起了我的ptsd：女教师，尖嗓门，照本宣科读ppt
* 本来掰开讲很有趣的东西硬生生讲成应试教育，**应试兴国**了属于是
* 教材还是老问题：编写者炫技用，不适合自学，这次也不适合当工具书
* ppt成功继承了教材的所有缺点，甚至不如知乎讲得明白
* B站大学的含金量仍在上升
* 感觉...不如 图灵完备
* 配合单片机学习更佳
* 对于该笔记，有以下定义
    * 位信号：以单线路位数为传播信息
    * 值信号：以多线路位为传播信息

## C1
* CPI:执行指令的平均周期 (Clock cycles Per Instruction)，反过来就是IPC，懂了不？
* MIPS：每秒百万条指令
* MFLOPS：每秒百万浮点操作

## C2
* 数字表示
    > **后续表示不算入符号位**  
    > **最低位为1即$2^{0}$，即位数=物理位置-1**
    * 原码：0.1001，小数点前为符号位
    * 反码：正数不变，负数取位反
    * 补码：**茴字有四种写法**
        * 变形补码：反码+1
        * $2^{n+1}-|x|$
        * $2^{n}+x$,符号位取反
        * 溢出判断：最高位的异或，1为溢出；符号位确定上下溢
    * 移码：$2^{n}+x$
        * 补码和移码(所有位)间转换只取反符号位
    * 整数上下溢（加减法）：最高位进位信号 * 符号位进位信号，双符号位计算后异或
* 浮点数
    * 表示：类似于科学计数法，分为阶码和尾数以及对应的符号位
    * 限制：正负均存在上下限
    * 规格化表示：尾数最高$log_{2}N$次不全为0
    * IEE754标准：1位尾数符号位，8位阶码（令127为0这样就能表示-128-127的数了），23位尾数
        * 阶码越大范围越广，尾数越大精度越高，绝对值越大越稀疏（非连续）
    * 二进制编码的十进制，用4位二进制表示十进制数字：8421，2421，余三

## C3
* 全加器：串行进位加法器，超前进位加法器
    * 串行进位：$C_{out} = X_{1} * X_{2} * C_{in}$  
    $S = X_{1} XOR X_{2} XOR C_{in}$  
    多位加法器串联进位即可
    * 超前进位：代补充，延迟固定但是面积更大，一般串联超前进位以平衡占地开销和延迟开销
* 乘法器：
    * 思路：逻辑右移（超位保留，缺位补0），累加
    * 负数：转补码计算
    * 硬件实现：乘法阵列器，串行加法器实现，结果给左一位，进位给右下一位
* 除法器：
    * 不做推荐：周期长占地大，可以乘一个很大的数再移位近似结果
    * 思路：逻辑左移，被除数+除数补码，余数为负则置商为0否则保留为1
        * 恢复余数法：如果商0，加原码再左移
        * 加减交替法：先左移（第一步不用）再根据商决定加减，**加补码为减，加原码为加**
* 浮点加法：
    * 规则：$2^{m}M_{x} \pm 2^{n}M_{y} * (m-n)/|m-n|$
        * 其中：$X=2^{m}M_{x},Y=2^{n}M_{Y}$
        * 总结：操你妈逼搞这么复杂干嘛
    * 计算：对齐小数点再加减：尾数左右移位，阶码$\pm1$
        * 舍入处理：尾数右移导致的数字丢失：丢失置1或忽略
        * 溢出处理：尾数的双符号位异或为1，且阶码无法缓解
* 浮点乘法：
    * 规则：阶码加减，尾数乘除

## C4
* 存储层次
    1. 寄存器：L1指令缓存，L2，DFF
    1. 高速缓存：L3，SRAM
    1. 主存：内存，DRAM
    1. 磁盘：光盘，硬盘，固态
    1. 外界：磁盘，光盘，网络存储系统
* 存放方式
    * 大小端：从头写/从尾写
    * 数据对齐：起始字节地址能被数据大小整除，浪费空间提升性能
* RAM：
    * 单元扩展：通过地址线过译码器控制行列，行选通然后进行读写。
    * SRAM：静态MOS存储单元
        * 详见DSD，两个反逻辑门，断电不保存数据
    * DRAM：动态MOS存储单元
        * 详见DSD，一个电容
        * 刷新：电子泄露导致数据丢失，读取再写入
            * 集中刷新：集中刷新所有行
            * 分散刷新：读写一次刷新一次部分，浪费
            * 异步刷新：128次刷新分散
        * 类似于固态，但是固态能稳定电子，单元数据容量更高
    * 连接方式：数据总线，地址总线，读写控制
        * 容量：$2^{地址线} * 数据线$
            * 地址线与数据线均位信号
        * 存储器扩展：译码器，部分位地址线做值信号
* ROM：只读存储器
    * MROM：掩膜写死
    * PROM：一次机会
    * EPROM：紫外线使能
    * EEPROM：上电就能改
    * Flash：快速擦写
* 并行存储系统：
    * 双端口：多组读写控制线，在地址不冲突的情况下可以并行操作
    * 单体多字：一次激活更多存储单元
    * 高/低位多体交叉：一个地址寄存器，串联/并联模块，前者易于扩容隔离，后者并行输出（不同于上一个，地址不一样）
* 高速缓冲存储器：cache
    * CPU太快了，RAM跟不上
    * 基本术语
        1. 命中hit：数据在cache里
        1. 缺失miss：不在cache里
        1. 块block：cache与ram交流的最小单位。
        1. 关键操作：数据查找，地址映射，替换策略，写入策略
        1. 数据块地址：主存11位块地址，4位块内偏移  
        缓存8位块地址和，4位块内偏移
    * cache读操作：
    ```c
    if(ReadAccess == 1) {
        if (findData != Cache) {
            read_RAM();
            if (isCacheFull == 1) clean_cache();
            distribute_cache(); //分配cache
            cache_adress_update();
            write_cahe(read_RAM());
        }
        read_data_from_cache();
        return;
    }
    ```
    * Cache写操作
    ```c
    if(WriteAccess == 1) {
        if (findData != Cache) {
            read_RAM();
            if(write_distri() == 0) {
                write_data_from_ram();
                return;
            } else {
                distribute_cache();
                cache_adress_update();
            }
        }
        write_data_from_cache();
        if(write_through() == 1) write_data_from_ram();
        return；
    }
    ```
    * 相连存储器：以内容作为地址访问的存储器
        * 检查数据是否载入cache
    * 地址映射
        > 字通过机器字长转为字节（8bit）  
        > 1kb=$2^{10}b$,1mb=$2^{20}b，1B=8b$
        * 全相联映射：cache任意一行可以存储主存的任意一块，反之亦然  
        主存块地址+字地址（块内偏移）
        * 直接相联映射：cache一块对应若干主存块  
        （块地址+行地址）+ 字地址
        * 组相联映射：将cache若干组为一组，主存区对应cache组，区内位移可以不同于组内位移。分组情况由题目给出  
        （块地址+组地址）+ 字地址
        * 对于distribute_cache()：以块/组块为基础单位操作
        * ~~呸，恶心啊~~

    * 替换策略
        * 先进先出：栈
        * 最不常使用：访问次数最少
        * 近期最少使用：最久未访问过的
        * 随机替换

## C5
* 指令系统
    > 程序计数器PC：存放下一次访存的地址，自增取出指令的长度且固定字长  
    * 指令组成：操作码op，地址码a
    * 字长度：指令长度，单字长，双字长，半字长
        * 定长：结构简单，控制线路简单
            * 显然，地址码越多，该类的总指令数会变少
        * 变长：结构灵活，充分利用，扩展好，控制复杂
    * 指令地址码：由指令包含的地址码数量决定
        * a1 op a2 -> a3
        * a1 op a2 -> a1或a2
        * 操作数可以来自通用寄存器R，也可以来自主存单元S
    * 寻址方式：寻找指令或者操作数有效地址的方式
        * 操作数寻址：
            1. R：通用寄存器
            1. R[x]:变址寄存器
            1. R[B]:基址寄存器
            1. S：操作数
            1. EA：操作数的有效地址，（EA）地址EA的内容
            1. D：形式地址
            * 立即寻址：地址码即操作数 ~~这tm应该叫不寻址，哪个大聪明发明的~~
            * 直接寻址：地址码为操作数地址
            * 寄存器寻址：地址码为寄存器地址
            * 间接寻址：地址码为操作数地址的地址（双指针）
            * 寄存器间接寻址：地址码为操作数地址的地址，第一层在通用寄存器，第二层在主存
            * 相对寻址：程序计数器和形式地址一起构成操作数
            * 变址寻址：变址寄存器和形式地址一起构成操作数
            * 基址寻址：基址寄存器和形式地址一起构成操作数
            * ~~嗯？喜欢自学？只是不考，懒鬼~~
        * 顺序寻址，跳跃寻址：前者PC自动调用，后者会对PC进行修改
    * 指令类型
        * 算数指令：加减乘除
        * 逻辑指令：位且或非，比较，逻辑移位
        * 移位操作：算数/逻辑移位，循环移位
        * 数据传送：取数，存数，传数，交换，清除累加器
        * 堆栈指令：出入栈
        * 程序控制：无条件转移指令，子程序调用
        * 输入输出：etc
    * RISC与CISC：
        * CISC(Complex Instruction System Computer)：指令多，格式多，字长不固定，访存指令不限制，指令见差距大
            * PDP-11，Intel X86
        * RISC(Reduced Instruction System Computer)：指令少且定长，寻址简单，大量寄存器
            * MIPS，ARM，RISC_V
        > 在指令读取到指令执行之间存在一个指令解码器，将指令翻译为微指令，**现代**RISC与CISC最大的不同便在于此。  
        > 最后都会翻译成类RISC指令，对于RISC来说前后区别不大所以解码器会轻松很多  

        > 分支预测：指令是按顺序进入执行单元的，但部分指令需要前一个指令的结果去选择下一个执行对象，分支预测即在前一个指令未完成的情况下去预测下一个指令的位置，如果失败会导致该指令需要重新执行。因此一个优秀的分支预测是高效处理器的不可或缺的一部分
## C6
* 处理器组成：
    * 主要寄存器：
        1. 程序计数器：详见上文
        1. 存储器地址寄存器AR：
        1. 存储器地址寄存器DR：
        1. 指令寄存器IR：
        1. 通用寄存器GR：
    * 操作控制器OC：接受译码，形成具有顺序的微操作控制信号
        * CPU执行指令的过程就是CPU控制信息流的过程，OC是决策器，分为硬布线（时序逻辑）微程序（存储程序）
    * 时序产生器：所有操作必须按照一定的次序进行，对微操作控制信号进行时间调制
* 指令周期：
    1. 一般流程
        * 取指令
        * 译码
        * 操作数地址计算
        * 取操作数
        * 数据操作指令执行
        * 操作时地址计算
        * 存操作数
        * 返回第一步/中断响应周期
    1. 基本概念
        * 时钟周期 = 节拍 = 振荡周期=一次微操作
        * 机器周期 = CPU周期=从主存读出一条指令的最短时间
        * 指令周期 = 取指并执行的时间
* 寄存器传送语言RTL
    1. 规则：
        * M[addr]：主存addr单元内容，addr为地址
        * R[i]：通用寄存器组中i号寄存器内容
        * ->：数据传递
        * $X_{y:z}$：寄存器y到z位的数据字段
        * SignEXt(t)：X扩展到32位
        * {x，y}：连接x，y
    1. 数据通路：数据流水线处理，受时钟驱动
        * 核心：DFF，时钟上升沿记录输入并保持该输出
        * 单总线/多总线：是否由多套AR，DR，PC
* MIPS指令集：结构简单，易于流水线CPU设计，易于编译器开发
    1. 格式：
        * R型：6bit空，5bit操作数*3(rs,rt,rd)，shamt，6bit Function
            * lw，sw，beq，addi
        * I型：6bit功能，5bit操作时*2，16bit立即数
            * add，slt
        * J型：6bit功能，26bit立即数，跳转目标地址
            * j
    1. lw：主存取32位的存储字
        1. 取指周期：PC参与两条数据通路：自增，取指
            * PC -> AR; PC-> X;
            * X + 4 -> X;
            * Z -> PC; M[AR] -> DR;  
            取出PC自增，访问指令
            * DR -> IR;
        1. 计算周期：R[rs]与IR[I]在ALU
            * R[rs] -> X;  
            准备计算访存地址
            * IR[I] + x -> Z;  
            扩展立即数为32位并送入ALU作加法运算
        1. 执行周期
            * Z -> AR;
            * M[AR] -> DR;
            * DR -> R[rt];
    1. sw：主存写32位的存储器字
        1. 取值周期
            * PC -> AR; PC -> X;
            * X + 4 -> Z;
            * Z -> PC; M[AR] -> DR;
            * DR -> IR;
        1. 计算周期
            * R[rs] -> X;
            * IR(I) + X -> Z
        1. 执行周期
            * Z -> AR;
            * R[rt] -> DR;
            * DR -> M[AR];
    1. beq：比较寄存器rs和rt的值
        1. 计算周期
            * R[rs] -> X;
            * X-R[rt] -> PSW
        1. 执行周期
            * PC -> X;
            * IR(A) + X -> Z;
            * if (PSW.equal) {Z -> PC}
    1. addi：rs+立即数->rd
        1. 执行周期
            * R[rs] -> X;
            * IR(I) + X -> Z;
            * Z -> R[rt];
    1. add：rs+rt -> rd
        1. 执行周期
            * R[rs] -> X;
            * R[rt] + X -> Z;
            * Z -> R[rd];
* 中央处理器时序
    1. 控制方式
        * 同步控制：对于定长指令周期：机器周期，节拍数固定；变长周期：机器周期不固定
        * 异步控制：无时钟，应答机制
        * 联合控制：1+2
    1. 时序发生器：输入译码指令与时钟信号，输出状态周期与节拍电位。可以开关
        * 作用：为组件提供时钟信号
        * 使用：FSM互联状态寄存器，当前状态输入时序发生器。对于变长指令，FSM需要译码信号
    1. 硬布线控制器：输入译码指令与反馈信号，输出控制信号序列
        * 作用：控制上面指令参加的寄存器的开关
        * 使用：FSM互联状态寄存器，当前状态接入硬布线控制器
        * 优缺点：速度快，但是设计复杂，不易调整
    1. 微程序控制器：对硬布线控制器的优化设计，存储控制信号序列，分级为若干节拍的微指令
        * 微指令：一个机器周期中一组实现操作功能的微命令，之间互不冲突。同样存在微指令周期，取指+执行
        * 微程序：实现一条机器指令功能的若干微指令
        * 组成原理
            1. 组成：地址转移逻辑接受IR与状态条件，判别字段与下址字段，输出后续地址给微地址寄存器，经由控制存储器输出微指令控制手段与下址，判断字段，后两个送回地址转移逻辑
                * 后续微地址的形成：由判别字段与状态条件控制MUX，分支地址（前面提到的顺序指令）/下地址直接输入微地址寄存器
            1. 微指令格式：操作控制字段+顺序控制字段（下址字段法）或 顺序控制（计数器法）
                * 控制字段可以接上译码器扩展使用
                * 水平型微指令：并行给出多个微命令的微指令（8发射处理器）
                * 垂直型微指令：完全编码化，简单但是被淘汰
        
## 作业
6.2（2）（3）（7）（8）（9）；6.3（7）（10）；6.4；6.20；6.23  
5.2（1）、（3）、（4）、（8）、（9）、（12）；5.3（4）；5.5；5.6；5.8  
4.2（1）（2）（7）（11）（12）（13）；4.3（3）；4.7；4.8；4.11；4.13；4.14  
3.2（1）、（2）、（5）、（7）；3.3（3）；3.4（2）；3.5（3）；3.6（1）；3.7（1）；3.8（2）；3.9（2）  
2.2（1）（5）（6）（8）；2.3（4）；2.4；2.10；2.11；2.14  
1.1，1.2（2）、（3）、（4）、（7），1.3,1.6  