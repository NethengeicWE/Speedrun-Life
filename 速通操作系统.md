# 速通机器学习
## 前言：
* 高情商：知识蒸馏效率极高，低情商：废话极多
* huawei赞助本课程，体现在要求安装OpenEuler和一大堆画饼ppt上
* **能不能好好讲明白函数执行？？？**
## C0：作业合集
### H2
1. **简述死锁的概念及其产生的四个必要条件**
    * 定义：是指两个或多个进程在执行过程中，因争夺资源而造成一种相互等待的现象，导致它们无法继续执行下去。死锁的进程将永久处于等待状态，无法释放已经占用的资源，从而导致系统无法继续执行相关操作。
    * 必要条件
        1. 互斥条件（Mutual Exclusion）某个资源在同一时刻只能由一个进程占用。如果其他进程请求该资源，必须等待。
        1. 占有并等待条件（Hold and Wait）一个进程至少持有一个资源，并且正在等待获得其他进程所持有的资源
        1. 不剥夺条件（No Preemption）已经分配给进程的资源，不能被强制剥夺，只能由持有进程主动释放。即使其他进程需要该资源，也不能将资源从当前进程强行剥夺。
        1. 循环等待条件（Circular Wait） 存在一个进程等待链，其中每个进程都在等待下一个进程所持有的资源，最终形成一个环路。即，进程A等待进程B持有的资源，进程B等待进程C持有的资源，依此类推，最后进程Z又等待进程A持有的资源
1.  **简述临界区域的概念及进入临界区域的四个准则**
    1. 互斥性（Mutual Exclusion）：同一时刻只有一个进程或线程可以执行临界区代码。
    1. 有限等待（Bounded Waiting）：保证每个进程最终可以进入临界区，避免无限等待。
    1. 无阻塞（No Blocking）：尽量避免进程阻塞，不影响其他进程执行。
    1. 不剥夺（No Preemption）：确保进程在进入临界区后，执行完毕才离开。
1. 计算题:某系统采用页式存储管理策略，物理地址空间的大小是4GB。设某进程的逻辑地址空间需要100页，页的大小为40KB，
    * **试写出物理地址格式。**  
        $\log_2(4GB/40KB) = 17$  
        $\log_240KB = 16$
        17位页，16位页内偏移
    * **试计算该进程的大小是多少字节?**  
        $40KB × 100 = 4MB$
    * **如果该进程的0、1、2、3页被分别装入内存的2、4、7、8块，试计算逻辑地址124000对应的物理地址。**  
        $逻辑页号 = \frac{124000}{\text{页大小}} = \frac{124000}{40,960} = 3 $  
        $页内偏移 = 124000 \mod 40960 = 1120 $  
        修改后的逻辑页号8：$8×40960+1120=328800$

### H3
1. **启动和读写一次磁盘包括哪几个具体时间?请简要叙述。**
    * 仅针对机械硬盘：寻道延迟，旋转延迟，数据传输延迟，命令处理延迟

1. **华为openEuler操作系统的主要全堆栈技术优化主要有哪五个？**
    * 硬件加速优化：深度定制支持硬件平台，提升计算和存储性能。
    * 高性能内核优化：提升系统内核性能，支持大规模并发和高效内存管理。
    * 容器与虚拟化技术优化：优化容器和虚拟化性能，提升云环境的资源利用效率。
    * 网络性能优化：优化网络协议栈、支持 RDMA，提升网络吞吐量和低延迟性能。
    * 安全性和可信计算优化：增强系统安全性，提供硬件加密支持和可信计算平台
1. **简述openEuler中socket编程的基本流程及主要函数。**
    1. 创建套接字 socket()
    1. 绑定地址 bind()（服务器端）
    1. 监听连接 listen()（服务器端）
    1. 接受连接 accept()（服务器端）或发起连接 connect()（客户端）
    1. 进行数据传输 send() / recv() 或 write() / read()
    1. 关闭套接字 close()
### H4
1. 桌上有一个盘子每次只能放一个水果，爸爸往盘子里放苹果，妈妈往盘子里放橘子。女儿专吃盘子里的苹果，儿子专吃盘子里的橘子。试使用信号量和P、V操作实现爸爸、妈妈、女儿和儿子之间的同步。试将下面的算法伪码的5个空格处补充完整。
    ```c
    #define blank0 1    // 盘子有空，初始化信号量s3为1
    #define blank1 P(s1) // 女儿等待苹果
    #define blank2 V(s3) // 女儿吃完苹果后释放盘子资源
    #define blank3 P(s3) // 妈妈等待盘子有空间
    #define blank4 V(s2) // 妈妈放橘子后释放橘子资源

    Semaphore s1 = 0, s2 = 0; s3 = blank0; // 信号量s1表示盘子里的苹果资源，信号量s2表示盘子里的橘子资源，信号量s3表示盘子资源。
    father() {
        while (1) {
            P(s3);
            放苹果;
            V(s1);
        }
    }
    daughter() {
        while (1) {
            blank1;
            吃苹果;
            blank2;
        }
    }

    mother() {
        while (1) {
            blank3;
            放橘子;
            blank4;
        }
    }
    son() {
        while (1) {
            P(s2);
            吃橘子;
            V(s3);
        }
    }
    ```

1. 在一个请求分页存储管理系统中，设某作业占有7个页面，进程P的访问次序为1，2，3，4，2，1，5，6，2，1，2，3，7，6，3，2，当分配给该进程的物理块为4时，请用FO算法和LRU置换算法计算访问过程中发生的缺页次数和缺页率以及分别淘汰的页面号序列。
    * FO算法：先进先出
        * 页面访问顺序：
        1. 访问1：缺页，将1加载到内存，内存状态：[1]
        1. 访问2：缺页，将2加载到内存，内存状态：[1, 2]
        1. 访问3：缺页，将3加载到内存，内存状态：[1, 2, 3]
        1. 访问4：缺页，将4加载到内存，内存状态：[1, 2, 3, 4]
        1. 访问2：命中，内存状态：[1, 2, 3, 4]
        1. 访问1：命中，内存状态：[1, 2, 3, 4]
        1. 访问5：缺页，淘汰1，加载5，内存状态：[5, 2, 3, 4]
        1. 访问6：缺页，淘汰2，加载6，内存状态：[5, 6, 3, 4]
        1. 访问2：缺页，淘汰3，加载2，内存状态：[5, 6, 2, 4]
        1. 访问1：缺页，淘汰4，加载1，内存状态：[5, 6, 2, 1]
        1. 访问2：命中，内存状态：[5, 6, 2, 1]
        1. 访问3：缺页，淘汰5，加载3，内存状态：[3, 6, 2, 1]
        1. 访问7：缺页，淘汰6，加载7，内存状态：[3, 7, 2, 1]
        1. 访问6：缺页，淘汰2，加载6，内存状态：[3, 7, 6, 1]
        1. 访问3：命中，内存状态：[3, 7, 6, 1]
        1. 访问2：缺页，淘汰1，加载2，内存状态：[3, 7, 6, 2]
        * 缺页次数：14次
        * 缺页率：87.5%
        * 淘汰的页面号序列：1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 2, 4, 6, 2
    * LRU算法：最少使用
        * 页面访问顺序：
        1. 访问1：缺页，将1加载到内存，内存状态：[1]
        1. 访问2：缺页，将2加载到内存，内存状态：[1, 2]
        1. 访问3：缺页，将3加载到内存，内存状态：[1, 2, 3]
        1. 访问4：缺页，将4加载到内存，内存状态：[1, 2, 3, 4]
        1. 访问2：命中，内存状态：[1, 3, 4, 2]
        1. 访问1：命中，内存状态：[3, 4, 2, 1]
        1. 访问5：缺页，淘汰3，加载5，内存状态：[4, 2, 1, 5]
        1. 访问6：缺页，淘汰4，加载6，内存状态：[2, 1, 5, 6]
        1. 访问2：命中，内存状态：[1, 5, 6, 2]
        1. 访问1：命中，内存状态：[5, 6, 2, 1]
        1. 访问2：命中，内存状态：[5, 6, 1, 2]
        1. 访问3：缺页，淘汰5，加载3，内存状态：[6, 1, 2, 3]
        1. 访问7：缺页，淘汰6，加载7，内存状态：[1, 2, 3, 7]
        1. 访问6：缺页，淘汰1，加载6，内存状态：[2, 3, 7, 6]
        1. 访问3：命中，内存状态：[2, 7, 6, 3]
        1. 访问2：命中，内存状态：[7, 6, 3, 2]
        * 缺页次数：12次
        * 缺页率：75%
        * 淘汰的页面号序列：3, 4, 5, 6, 1, 6
    
**完全整理的函数库**
```c
/**
 * @brief POSIX线程库的创建
 * 与父线程共享相同的地址空间、文件描述符等资源，但它们是独立的执行单元，有自己的栈和寄存器状态
 * 编译时需要链接-lpthread，这个操作在不同发行版上有所不同
    * @param thread：返回新线程的线程 ID 
    * @param attr：线程属性
    * @param start_routine：新线程将执行的函数
    * @param arg：传递给新线程的参数
 * @return 执行结果
*/
int pthread_create(pthread_t *thread, const pthread attr t *attr,void *(*start rtn) (void*), void * arg);


/**
 * @brief  Linux 系统调用的新线程/进程创建,功能强大但更低级
    * @param flags：决定父子进程或线程的资源共享方式
    * @param child_stack：指向子进程或子线程栈的指针
    * @param parent_tid：父进程/线程的线程 ID
    * @param child_tid：子进程/线程的线程 ID
    * @param tls：线程局部存储
 * @return 执行结果
*/
int clone(int flags, void *child_stack, int *parent_tid, int *child_tid, unsigned long tls);
struct semaphore {
    int value;
    struct PCB *queue;
}

int pthread_join();
int pthread_detach();

pthread_    线程自身及其他子例程
pthread_attr_   线程属性对象
pthread_mutex_  互斥变量
pthread_mutexattr_  互斥属性对象
pthread_cond_   条件变量
pthread_condattr_   条件属性对象
pthread_key_    特定线程数据键
// 静态方式
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
// 动态方式
int pthread_mutex_init(pthread mutex t *mutex,
const pthread mutexattr t :
*mutexattr)

int pthread_mutex_lock(pthread mutex t *mutex);
// 若mutex已被其他线程加锁，该调用会阻塞线程直到mutex被解锁
int pthread_mutex_unlock(pthread mutex t *mutex);
// 当拥有mutex的线程使用完保护资源后，应该调用该解锁mutex。

sem_init();
sem_destroy();
sem_wait();
sem_post();
/* 伪代码有问题！应该先检查资源再操作信号量/阻塞线程 */
// 申请
void wait(semaphore s) {
    if (s.value < 0) block(s.queue); // 将进程阻塞，并将其投入等待队列s.queue */
    else {
        s.value --;
        function();
    }
}

// 释放：
/* 伪代码有问题！应该先检查阻塞队列再操作信号量 */
void signal(semaphore s)/* V操作*/
    if (len(s.queue) > 0) wackup(s.queue);
    /*唤醒进程，将其从等待队列s.queue取出，投入就绪队列*/
```
## C1：
* 计算机启动过程
* 中断处理过程
* 定义
* 历史：bingbingbongbong
* 特征：并发，共享，虚拟，不确定
* 功能：存储，进程，设备，文件，用户管理
* 类型：分时，实时，微机，多机，网络，分布式
## C2：
* 虚拟机安装教程
> 建议使用ubuntu on wsl2
## C3
* 并发与并行
    1. 并行：指令，线程，进程（真正意义上的）同时进行
    1. 并发：任务基于时间片轮流执行，看起来像是同时执行
    * Bernstein条件：资源占用冲突
* 进程状态：就绪，运行，阻塞，挂起
    > 详见速通FreRTOS  
    * 面向进程控制块PCB操作
    * **线程：进程的最小执行单元**
* linux系统
    > 详见菜鸟教程：https://www.runoob.com/linux/linux-tutorial.html
* c代码编译  
    gcc [源文件] -o [目标文件]
    * 过程：.c -> .i预处理 ->.s(转汇编) -> .o(目标文件) ->(可执行)
    * 可选编译参数：
        1. -O[n]：优化程度，n属于0-3,n=s优化大小
        1. -g：生成调试信息
        1. -Wall：启用所有警告
        1. -Werror：所有警告视作错误
        1. -std=c99：使用c99标准
        1. -L[dir]/[library]：链接指定位置的文件/库
        1. -static：生成静态链接可执行库
        1. -shared；动态链接库
        1. -march=[arch]：指定
        1. -I[dir]:指定头文件
## C5
* 线程：用户创建和内核创建
* 创建：
```c
pid_t fork(void);   // 子进程完全复制父进程的资源
pid_t vfork(void);
int clone(int (*fn)(void * arg), void *stack, int flags, void *)
// 进程等待
pid_t wait(int *status);
pid_t waitpid(pid t pid, int *status, int options);
// 进程终止
exit(int status);
```

## C6
**无**

## C7
**进程间的关系：同步，互斥，通信**
* 临界资源：只有一个坑位的厕所
    > **准则：空闲让进，忙则阻塞，有限等待，让权等待**
    * 工具：信号量的**P**roberen申请，**V**erhogen释放（详见FreeRTOS）
    ```c
    // 这里有代码，等待补充
    ```
    * 进程同步问题：生产-消费者问题
        * 问题：避免资源竞争，死锁
        * 解决：三个信号量：访问控制，空，满
* 信号量的问题：效率低，不透明
    * 解决：消息缓冲队列
```c
// 这里有代码，等待补充
struct message_buffer b;
```

## C9:存储管理