# 速通操作系统
## 前言：
* 高情商：知识蒸馏效率极高，低情商：废话极多
* huawei赞助本课程，体现在要求安装OpenEuler和一大堆画饼ppt上
* **能不能好好讲明白函数执行？？？**
## C-1: 划重点

### 1. **死锁（Deadlock）**
死锁是指一组进程在执行过程中，由于竞争资源或通信问题，导致相互等待而无法继续执行的情况。死锁发生时，进程不会释放所占有的资源，从而造成系统中断或资源无法被利用。死锁的四个必要条件是：
- **互斥**：每个资源只能由一个进程占用。
- **请求与保持**：进程在占有一些资源的同时，提出对其他资源的请求。
- **不剥夺**：资源不能被强制从进程中剥夺，只能在进程使用完毕后自行释放。
- **循环等待**：进程在形成一个环形等待的状态时。

#### 死锁预防与避免：
- **资源分配图**：通过图表示资源与进程的关系，避免形成死锁。
- **银行家算法**：通过对系统资源的安全性检查，确保资源分配不会导致死锁。

### 2. **临界区域（Critical Section）**
临界区域是指一段代码或程序块，这段代码在执行时需要访问共享资源（如共享变量、文件等），并且同一时刻只能有一个进程或线程进入执行。临界区问题是指如何在多个进程或线程之间协调访问共享资源，以防止数据冲突或错误。

#### 解决临界区问题的方法：
- **互斥锁（Mutex）**：通过锁机制，保证同一时刻只有一个线程能够进入临界区。
- **信号量**、**条件变量**、**读写锁**等。

### 3. **信号量（Semaphore）**
信号量是一种同步工具，用来控制访问共享资源的进程数目。信号量可以被视为一个整数，它有两个主要操作：
- **P操作**（等待操作）：如果信号量值大于0，则将信号量减1；如果信号量为0，进程将被阻塞，直到信号量值大于0。
- **V操作**（释放操作）：将信号量的值加1，如果有进程因为信号量值为0而阻塞，则唤醒它。

信号量有两种类型：
- **计数信号量**：用于控制多个资源的访问。
- **二值信号量（Mutex）**：用于控制对单一资源的访问，只有0和1两种状态。

### 4. **进程状态（Process State）**
进程是操作系统资源分配的基本单位，进程在运行过程中会经历多个状态：
- **就绪（Ready）**：进程已经准备好，可以执行，但等待CPU。
- **运行（Running）**：进程正在使用CPU执行。
- **阻塞（Blocked）**：进程由于等待某些事件（如I/O操作）而无法继续执行。
- **终止（Terminated）**：进程执行完毕或被终止。

### 5. **同步（Synchronization）**
同步是指多个进程或线程协调执行的过程，确保它们按照正确的顺序访问共享资源。同步可以避免竞争条件（race condition）和数据不一致。

#### 同步方法：
- **互斥锁（Mutex）**：防止多个进程或线程并发访问临界区。
- **条件变量**：用于线程间的通知机制，通常与互斥锁结合使用。
- **信号量**：用于控制多个线程对共享资源的访问。

### 6. **互斥（Mutual Exclusion）**
互斥是指在同一时刻，只有一个进程或线程能够访问共享资源。为了防止多个进程同时进入临界区，使用互斥机制，如互斥锁（mutex）或信号量。

### 7. **CPU调度算法（CPU Scheduling Algorithms）**
CPU调度算法是操作系统中用于决定哪个进程在何时使用CPU的策略。常见的调度算法有：
- **先来先服务（FCFS）**：按照进程到达的顺序来调度。
- **短作业优先（SJF）**：优先执行估计运行时间最短的进程。
- **时间片轮转（RR）**：每个进程轮流获得CPU的使用权。
- **优先级调度**：根据进程优先级进行调度。
- **多级反馈队列（MLFQ）**：结合多种调度策略，适应不同类型的进程。

### 8. **虚拟存储（Virtual Memory）**
虚拟存储是一种内存管理技术，使得程序认为自己拥有连续的内存空间，实际上这些内存可能是分散在物理内存和磁盘上的。虚拟存储通过**分页**或**分段**机制将程序的地址空间映射到物理内存中，允许更高效的内存利用和进程隔离。

### 9. **页面大小换算（Page Size Calculation）**
在分页存储管理中，操作系统将进程的地址空间分成多个固定大小的页面。页面的大小是操作系统设计时的参数，常见的页面大小有4KB、8KB、16KB等。

#### 计算示例：
- 如果一个进程占用的虚拟地址空间是16MB，且每个页面的大小是4KB，则需要的页面数为：  
  `16MB ÷ 4KB = 4096 页`

### 10. **磁盘读写时间计算（Disk Read/Write Time Calculation）**
磁盘的读写时间主要由以下几个部分组成：
- **寻道时间（Seek Time）**：磁头移动到目标轨道的时间。
- **旋转延迟（Rotational Latency）**：磁盘旋转一圈的时间（通常与磁盘的转速有关）。
- **传输时间（Transfer Time）**：从磁盘传输数据到内存的时间。

总的磁盘读写时间 = 寻道时间 + 旋转延迟 + 传输时间。

### 11. **请求分页存储中的缺页计算（Page Fault Calculation）**
在分页存储管理中，缺页是指进程需要访问的页面不在物理内存中。缺页时，操作系统会从磁盘加载该页面到内存，过程叫做**缺页中断**。

#### 计算缺页率：
- **缺页率**：缺页次数 / 总访问次数
- **缺页处理时间**：每次缺页的时间包括磁盘读取时间、上下文切换时间等。

### 12. **页式存储地址映射（Page Table Address Mapping）**
页式存储通过页表将虚拟地址映射到物理地址。页表通常包括每个页面的物理内存地址。虚拟地址可以分为两部分：
- **页号（Page Number）**：用于查找页表，映射到物理页帧。
- **页内偏移（Offset）**：指示页面内的具体位置。

### 13. **Socket通信编程（Socket Programming）**
Socket是网络编程中用于进程间通信的接口，支持不同计算机之间的通信。常见的操作有：
- **创建Socket**：`socket()`
- **绑定Socket**：`bind()`
- **监听Socket**：`listen()`
- **接受连接**：`accept()`
- **发送数据**：`send()` 或 `write()`
- **接收数据**：`recv()` 或 `read()`

Socket通信可以使用**TCP**（面向连接）或**UDP**（无连接）协议。

### 14. **文件操作（File Operations）**
文件操作是操作系统提供的对磁盘文件的基本操作。常见的文件操作有：
- **打开文件**：`open()`
- **读取文件**：`read()` 或 `fread()`
- **写入文件**：`write()` 或 `fwrite()`
- **关闭文件**：`close()`
- **文件定位**：`lseek()`
- **文件权限管理**：`chmod()`
- **文件删除**：`remove()` 或 `unlink()` 

文件操作通常是通过系统调用接口进行的。

## C0：作业合集
### H2
1. **简述死锁的概念及其产生的四个必要条件**
    * 定义：是指两个或多个进程在执行过程中，因争夺资源而造成一种相互等待的现象，导致它们无法继续执行下去。死锁的进程将永久处于等待状态，无法释放已经占用的资源，从而导致系统无法继续执行相关操作。
    * 必要条件
        1. 互斥条件（Mutual Exclusion）某个资源在同一时刻只能由一个进程占用。如果其他进程请求该资源，必须等待。
        1. 占有并等待条件（Hold and Wait）一个进程至少持有一个资源，并且正在等待获得其他进程所持有的资源
        1. 不剥夺条件（No Preemption）已经分配给进程的资源，不能被强制剥夺，只能由持有进程主动释放。即使其他进程需要该资源，也不能将资源从当前进程强行剥夺。
        1. 循环等待条件（Circular Wait） 存在一个进程等待链，其中每个进程都在等待下一个进程所持有的资源，最终形成一个环路。即，进程A等待进程B持有的资源，进程B等待进程C持有的资源，依此类推，最后进程Z又等待进程A持有的资源
1.  **简述临界区域的概念及进入临界区域的四个准则**
    1. 互斥性（Mutual Exclusion）：同一时刻只有一个进程或线程可以执行临界区代码。
    1. 有限等待（Bounded Waiting）：保证每个进程最终可以进入临界区，避免无限等待。
    1. 无阻塞（No Blocking）：尽量避免进程阻塞，不影响其他进程执行。
    1. 不剥夺（No Preemption）：确保进程在进入临界区后，执行完毕才离开。
1. 计算题:某系统采用页式存储管理策略，物理地址空间的大小是4GB。设某进程的逻辑地址空间需要100页，页的大小为40KB，
    * **试写出物理地址格式。**  
        $\log_2(4GB/40KB) = 17$  
        $\log_240KB = 16$
        17位页，16位页内偏移
    * **试计算该进程的大小是多少字节?**  
        $40KB × 100 = 4MB$
    * **如果该进程的0、1、2、3页被分别装入内存的2、4、7、8块，试计算逻辑地址124000对应的物理地址。**  
        $逻辑页号 = \frac{124000}{\text{页大小}} = \frac{124000}{40,960} = 3 $  
        $页内偏移 = 124000 \mod 40960 = 1120 $  
        修改后的逻辑页号8：$8×40960+1120=328800$

### H3
1. **启动和读写一次磁盘包括哪几个具体时间?请简要叙述。**
    * 仅针对机械硬盘：寻道延迟，旋转延迟，数据传输延迟，命令处理延迟

1. **华为openEuler操作系统的主要全堆栈技术优化主要有哪五个？**
    * 硬件加速优化：深度定制支持硬件平台，提升计算和存储性能。
    * 高性能内核优化：提升系统内核性能，支持大规模并发和高效内存管理。
    * 容器与虚拟化技术优化：优化容器和虚拟化性能，提升云环境的资源利用效率。
    * 网络性能优化：优化网络协议栈、支持 RDMA，提升网络吞吐量和低延迟性能。
    * 安全性和可信计算优化：增强系统安全性，提供硬件加密支持和可信计算平台
1. **简述openEuler中socket编程的基本流程及主要函数。**
    1. 创建套接字 socket()
    1. 绑定地址 bind()（服务器端）
    1. 监听连接 listen()（服务器端）
    1. 接受连接 accept()（服务器端）或发起连接 connect()（客户端）
    1. 进行数据传输 send() / recv() 或 write() / read()
    1. 关闭套接字 close()
### H4
1. 桌上有一个盘子每次只能放一个水果，爸爸往盘子里放苹果，妈妈往盘子里放橘子。女儿专吃盘子里的苹果，儿子专吃盘子里的橘子。试使用信号量和P、V操作实现爸爸、妈妈、女儿和儿子之间的同步。试将下面的算法伪码的5个空格处补充完整。
    ```c
    #define blank0 1    // 盘子有空，初始化信号量s3为1
    #define blank1 P(s1) // 女儿等待苹果
    #define blank2 V(s3) // 女儿吃完苹果后释放盘子资源
    #define blank3 P(s3) // 妈妈等待盘子有空间
    #define blank4 V(s2) // 妈妈放橘子后释放橘子资源

    Semaphore s1 = 0, s2 = 0; s3 = blank0; // 信号量s1表示盘子里的苹果资源，信号量s2表示盘子里的橘子资源，信号量s3表示盘子资源。
    father() {
        while (1) {
            P(s3);
            放苹果;
            V(s1);
        }
    }
    daughter() {
        while (1) {
            blank1;
            吃苹果;
            blank2;
        }
    }

    mother() {
        while (1) {
            blank3;
            放橘子;
            blank4;
        }
    }
    son() {
        while (1) {
            P(s2);
            吃橘子;
            V(s3);
        }
    }
    ```

1. 在一个请求分页存储管理系统中，设某作业占有7个页面，进程P的访问次序为1，2，3，4，2，1，5，6，2，1，2，3，7，6，3，2，当分配给该进程的物理块为4时，请用FO算法和LRU置换算法计算访问过程中发生的缺页次数和缺页率以及分别淘汰的页面号序列。
    * FO算法：先进先出
        * 页面访问顺序：
        1. 访问1：缺页，将1加载到内存，内存状态：[1]
        1. 访问2：缺页，将2加载到内存，内存状态：[1, 2]
        1. 访问3：缺页，将3加载到内存，内存状态：[1, 2, 3]
        1. 访问4：缺页，将4加载到内存，内存状态：[1, 2, 3, 4]
        1. 访问2：命中，内存状态：[1, 2, 3, 4]
        1. 访问1：命中，内存状态：[1, 2, 3, 4]
        1. 访问5：缺页，淘汰1，加载5，内存状态：[5, 2, 3, 4]
        1. 访问6：缺页，淘汰2，加载6，内存状态：[5, 6, 3, 4]
        1. 访问2：缺页，淘汰3，加载2，内存状态：[5, 6, 2, 4]
        1. 访问1：缺页，淘汰4，加载1，内存状态：[5, 6, 2, 1]
        1. 访问2：命中，内存状态：[5, 6, 2, 1]
        1. 访问3：缺页，淘汰5，加载3，内存状态：[3, 6, 2, 1]
        1. 访问7：缺页，淘汰6，加载7，内存状态：[3, 7, 2, 1]
        1. 访问6：缺页，淘汰2，加载6，内存状态：[3, 7, 6, 1]
        1. 访问3：命中，内存状态：[3, 7, 6, 1]
        1. 访问2：缺页，淘汰1，加载2，内存状态：[3, 7, 6, 2]
        * 缺页次数：14次
        * 缺页率：87.5%
        * 淘汰的页面号序列：1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 2, 4, 6, 2
    * LRU算法：最少使用
        * 页面访问顺序：
        1. 访问1：缺页，将1加载到内存，内存状态：[1]
        1. 访问2：缺页，将2加载到内存，内存状态：[1, 2]
        1. 访问3：缺页，将3加载到内存，内存状态：[1, 2, 3]
        1. 访问4：缺页，将4加载到内存，内存状态：[1, 2, 3, 4]
        1. 访问2：命中，内存状态：[1, 3, 4, 2]
        1. 访问1：命中，内存状态：[3, 4, 2, 1]
        1. 访问5：缺页，淘汰3，加载5，内存状态：[4, 2, 1, 5]
        1. 访问6：缺页，淘汰4，加载6，内存状态：[2, 1, 5, 6]
        1. 访问2：命中，内存状态：[1, 5, 6, 2]
        1. 访问1：命中，内存状态：[5, 6, 2, 1]
        1. 访问2：命中，内存状态：[5, 6, 1, 2]
        1. 访问3：缺页，淘汰5，加载3，内存状态：[6, 1, 2, 3]
        1. 访问7：缺页，淘汰6，加载7，内存状态：[1, 2, 3, 7]
        1. 访问6：缺页，淘汰1，加载6，内存状态：[2, 3, 7, 6]
        1. 访问3：命中，内存状态：[2, 7, 6, 3]
        1. 访问2：命中，内存状态：[7, 6, 3, 2]
        * 缺页次数：12次
        * 缺页率：75%
        * 淘汰的页面号序列：3, 4, 5, 6, 1, 6
    
**完全整理的函数库**
```c
/**
 * @brief 创建一个新的POSIX线程
 * pthread_create 函数用于创建一个新的线程，新线程将与调用线程共享同一进程的地址空间、文件描述符、全局变量等资源，
 * 但拥有独立的栈、寄存器上下文等。
 * @note
 *  - 编译时需要链接线程库（例如，在 Linux 上需要添加 `-pthread` 选项）。
 *  - `pthread_create` 返回值为 0 表示创建线程成功；返回错误码则表示失败。
 * 
 * @param thread[out]：新线程的线程 ID（通过该参数返回）。
 * @param attr[in]：线程属性（可设置为 NULL，表示使用默认线程属性）。
 * @param start_routine[in]：新线程将执行的函数的入口地址。
 * @param arg[in]：传递给新线程的参数，可以为 NULL。
 * 
 * @return
 *  - 0：成功创建线程。
 *  - 非零值：错误码，表示线程创建失败。
 */
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);

/**
 * @brief 创建一个新的进程或线程（Linux系统调用）
 * `clone` 是 Linux 系统中的一个低级函数，用于创建一个新进程或线程。它与 `fork` 和 `pthread_create` 的功能相似，
 * 但是提供了更高的灵活性。`clone` 可以让父子进程或线程共享或不共享资源，具体由 `flags` 参数来控制。
 * @note
 * - `clone` 是 Linux 系统调用，因此需要包含头文件 `<sched.h>`。
 * - `clone` 函数的行为取决于传入的 `flags` 参数。例如，可以选择是否将 `child_stack` 作为新线程的栈， 
 *   是否共享内存空间、文件描述符等资源。
 * @param flags[in]：指定 `clone` 的行为（如创建线程或进程的方式）。此参数可以是多种 `CLONE_` 标志的组合， 
 *                   比如 `CLONE_VM` 表示共享虚拟内存，`CLONE_FILES` 表示共享文件描述符等。
 * @param child_stack[in]：新线程的栈，指向新线程栈的起始位置。如果为 `NULL`，则表示不传递栈。
 * @param parent_tid[out]：父线程的线程 ID（可选）。只有在 `CLONE_PARENT_SETTID` 标志设置时，该值才有效。
 * @param child_tid[out]：子线程的线程 ID（可选）。只有在 `CLONE_CHILD_SETTID` 或 `CLONE_CHILD_CLEARTID` 标志设置时，该值才有效。
 * @param tls[in]：线程局部存储（TLS）。可以是一个地址，用于设置子线程的 TLS 数据。通常在多线程环境中使用。
 * 
 * @return
 *  - 返回子进程（或线程）ID，如果调用成功。
 *  - 返回负值，表示发生错误。
 */
int clone(int flags, void *child_stack, int *parent_tid, int *child_tid, unsigned long tls);


/**
 * @brief 等待指定线程结束并获取其返回值。
 * pthread_join 函数用于阻塞调用线程，直到目标线程执行完毕，同时可以获取目标线程的返回值。
 * @param thread[in]：线程 ID，表示需要等待的线程。
 * @param retval[out]：存储目标线程的返回值，可以为 NULL。
 * 
 * @return
 *  - 0：成功。
 *  - 非零错误码：失败，例如线程不可连接。
 * 
 * @note
 *  - 目标线程必须是可连接状态（默认情况下是可连接的）。
 *  - 如果目标线程已经被 pthread_detach 分离，则不能使用 pthread_join。
 * 
 * @usage
 *  - 用于线程间的同步，确保一个线程在另一个线程结束后继续运行。
 *  - 常用于获取目标线程的执行结果。
 */
int pthread_join(pthread_t thread, void **retval);

/**
 * @brief 将目标线程设置为分离状态。
 * pthread_detach 函数使目标线程在结束时，其资源（如线程栈）会自动回收，而无需其他线程调用 pthread_join。
 * 
 * @param thread[in]：线程 ID，表示需要分离的线程。
 * 
 * @return
 *  - 0：成功。
 *  - 非零错误码：失败。
 * 
 * @note
 *  - 分离线程不能再被 pthread_join 等待。
 *  - 线程资源会在目标线程结束时自动回收。
 * 
 * @usage
 *  - 在不需要等待线程结束、且希望资源自动回收时使用。
 *  - 适合后台运行的线程，或不关心其执行结果的线程。
 */
int pthread_detach(pthread_t thread);


/**
 * @category 线程自身及其他子例程
 * @brief 操作线程的基本接口，包括创建、终止、等待等操作。
 * 
 * - `pthread_create`：创建新线程。
 * - `pthread_exit`：终止调用线程。
 * - `pthread_join`：等待线程终止。
 * - `pthread_detach`：分离线程，允许线程在终止时释放资源。
 * - `pthread_self`：获取调用线程的线程标识符。
 * - `pthread_equal`：比较两个线程标识符是否相等。
 */

/**
 * @category 线程属性对象
 * @brief 配置线程的行为，例如栈大小、优先级、分离状态等。
 * 
 * - `pthread_attr_init`：初始化线程属性对象。
 * - `pthread_attr_destroy`：销毁线程属性对象。
 * - `pthread_attr_setdetachstate`：设置线程的分离状态。
 * - `pthread_attr_getdetachstate`：获取线程的分离状态。
 * - `pthread_attr_setstacksize`：设置线程栈大小。
 * - `pthread_attr_getstacksize`：获取线程栈大小。
 * - `pthread_attr_setinheritsched`：设置线程是否继承调度参数。
 * - `pthread_attr_getinheritsched`：获取线程的调度参数继承属性。
 */

/**
 * @category 互斥变量
 * @brief 提供互斥锁的创建、销毁、加锁和解锁功能，用于线程间的同步。
 * 
 * - `pthread_mutex_init`：初始化互斥锁。
 * - `pthread_mutex_destroy`：销毁互斥锁。
 * - `pthread_mutex_lock`：加锁，阻塞线程直到获得锁。
 * - `pthread_mutex_trylock`：尝试加锁，立即返回锁状态。
 * - `pthread_mutex_unlock`：解锁互斥锁。
 */

/**
 * @category 互斥属性对象
 * @brief 配置互斥锁的行为，例如是否为递归锁。
 * 
 * - `pthread_mutexattr_init`：初始化互斥锁属性对象。
 * - `pthread_mutexattr_destroy`：销毁互斥锁属性对象。
 * - `pthread_mutexattr_settype`：设置互斥锁类型（如普通锁、递归锁）。
 * - `pthread_mutexattr_gettype`：获取互斥锁类型。
 */

/**
 * @category 条件变量
 * @brief 提供线程间的条件等待和信号功能，用于同步。
 * 
 * - `pthread_cond_init`：初始化条件变量。
 * - `pthread_cond_destroy`：销毁条件变量。
 * - `pthread_cond_wait`：阻塞线程，直到接收到条件信号。
 * - `pthread_cond_timedwait`：带超时的条件等待。
 * - `pthread_cond_signal`：唤醒一个等待条件变量的线程。
 * - `pthread_cond_broadcast`：唤醒所有等待条件变量的线程。
 */

/**
 * @category 条件属性对象
 * @brief 配置条件变量的行为，例如时钟类型。
 * 
 * - `pthread_condattr_init`：初始化条件属性对象。
 * - `pthread_condattr_destroy`：销毁条件属性对象。
 * - `pthread_condattr_setclock`：设置条件变量的时钟类型。
 * - `pthread_condattr_getclock`：获取条件变量的时钟类型。
 */

/**
 * @category 特定线程数据键
 * @brief 提供线程局部存储（Thread Local Storage，TLS）的支持，每个线程都有独立的数据存储。
 * 
 * - `pthread_key_create`：创建一个线程特定数据键。
 * - `pthread_key_delete`：删除一个线程特定数据键。
 * - `pthread_setspecific`：设置线程特定数据的值。
 * - `pthread_getspecific`：获取线程特定数据的值。
 */

// 静态方式
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
// 动态方式
/**
 * @brief 初始化一个互斥锁（mutex）
 * 
 * pthread_mutex_init 函数用于初始化一个互斥锁。初始化后的互斥锁可用于线程间同步，
 * 用来保护共享资源，防止多个线程同时访问时出现竞争条件。
 * 
 * @note
 *  - 在使用互斥锁之前必须先进行初始化，可以使用 `pthread_mutex_init` 动态初始化或 
 *    `PTHREAD_MUTEX_INITIALIZER` 静态初始化。
 *  - 如果互斥锁不再需要使用，必须使用 `pthread_mutex_destroy` 释放其相关资源。
 *  - 如果传入 `NULL` 作为属性参数（`mutexattr`），互斥锁将使用默认属性（即 `PTHREAD_MUTEX_DEFAULT`）。
 *  - 一个互斥锁只能被初始化一次，否则可能导致未定义行为。
 * 
 * @param mutex[out]：指向待初始化互斥锁的指针。
 * @param mutexattr[in]：指定互斥锁的属性。可设置为 NULL 表示使用默认属性。
 * 
 * @return
 *  - 0：成功初始化互斥锁。
 *  - 非零值：错误码，表示初始化失败。
 *    - `EINVAL`：提供的属性无效。
 *    - `EBUSY`：互斥锁已被初始化。
 *    - `EAGAIN`：系统无法分配初始化所需的资源。
 *  */
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);

int pthread_mutex_lock(pthread mutex t *mutex);
// 若mutex已被其他线程加锁，该调用会阻塞线程直到mutex被解锁
int pthread_mutex_unlock(pthread mutex t *mutex);
// 当拥有mutex的线程使用完保护资源后，应该调用该解锁mutex。

sem_init();
sem_destroy();
sem_wait();
sem_post();
/* 伪代码有问题！应该先检查资源再操作信号量/阻塞线程 */
// 申请
void wait(semaphore s) {
    if (s.value < 0) block(s.queue); // 将进程阻塞，并将其投入等待队列s.queue */
    else {
        s.value --;
        function();
    }
}

// 释放：
/* 伪代码有问题！应该先检查阻塞队列再操作信号量 */
void signal(semaphore s)/* V操作*/
    if (len(s.queue) > 0) wackup(s.queue);
    /*唤醒进程，将其从等待队列s.queue取出，投入就绪队列*/
```
## C1：
* 计算机启动过程
* 中断处理过程
* 定义
* 历史：bingbingbongbong
* 特征：并发，共享，虚拟，不确定
* 功能：存储，进程，设备，文件，用户管理
* 类型：分时，实时，微机，多机，网络，分布式
## C2：
* 虚拟机安装教程
> 建议使用ubuntu on wsl2
## C3
* 并发与并行
    1. 并行：指令，线程，进程（真正意义上的）同时进行
    1. 并发：任务基于时间片轮流执行，看起来像是同时执行
    * Bernstein条件：资源占用冲突
* 进程状态：就绪，运行，阻塞，挂起
    > 详见速通FreRTOS  
    * 面向进程控制块PCB操作
    * **线程：进程的最小执行单元**
* linux系统
    > 详见菜鸟教程：https://www.runoob.com/linux/linux-tutorial.html
* c代码编译  
    gcc [源文件] -o [目标文件]
    * 过程：.c -> .i预处理 ->.s(转汇编) -> .o(目标文件) ->(可执行)
    * 可选编译参数：
        1. -O[n]：优化程度，n属于0-3,n=s优化大小
        1. -g：生成调试信息
        1. -Wall：启用所有警告
        1. -Werror：所有警告视作错误
        1. -std=c99：使用c99标准
        1. -L[dir]/[library]：链接指定位置的文件/库
        1. -static：生成静态链接可执行库
        1. -shared；动态链接库
        1. -march=[arch]：指定
        1. -I[dir]:指定头文件
## C5
* 线程：用户创建和内核创建
* 创建：
```c
pid_t fork(void);       // 子进程完全复制父进程的资源
pid_t vfork(void);
int clone(int (*fn)(void * arg), void *stack, int flags, void *)
pid_t wait(int *status);// 进程等待
pid_t waitpid(pid t pid, int *status, int options);// 进程终止
exit(int status);
```

## C6
**无**

## C7
**进程间的关系：同步，互斥，通信**
* 临界资源：只有一个坑位的厕所
    > **准则：空闲让进，忙则阻塞，有限等待，让权等待**
    * 工具：信号量的**P**roberen申请，**V**erhogen释放（详见FreeRTOS）
    ```c
    // 这里有代码，等待补充
    ```
    * 进程同步问题：生产-消费者问题
        * 问题：避免资源竞争，死锁
        * 解决：三个信号量：访问控制，空，满
* 信号量的问题：效率低，不透明
    * 解决：消息缓冲队列
```c
struct message_bufferchar {
    char sender[30];                // 发送进程标识符
    int size;                       // 消息长度
    char text[200];                 // 消息正文
    struct message_buffer *next;    //指向下一个消息缓冲区的指针
}

struct process_controlstruct {
    struct message_buffer *mq;      // 消息队列队首指针*
    semaphore mutex=l;              // 消息队列互斥信号量，初值为1*
    semaphore sm=0;                 // 消息队列同步信号量，记录消息的个数.初值为0
}

/**
 * @brief 创建一个新的消息队列或获取一个现有的消息队列。
 * msgget 函数用于创建或访问一个消息队列，用于在进程间传递消息。
 * 
 * @param key[in]：标识消息队列的键值。
 *  - `IPC_PRIVATE`：创建一个新的队列，只有调用进程的子进程可以访问。
 *  - 自定义键值：获取或创建具有该键值的消息队列。
 * @param msgflg[in]：操作标志。
 *  - 如果包含 IPC_CREAT：创建队列（如果不存在）。
 *  - 如果包含 IPC_EXCL：与 IPC_CREAT 一起使用，若队列已存在则返回错误。
 *  - 权限标志：设置队列的权限，如 `0666`（读写权限）。
 * 
 * @return
 *  - 非负整数：成功，返回消息队列的标识符。
 *  - -1：失败，`errno` 会设置相应的错误码。
 * 
 * @usage
 *  - 创建和访问消息队列，用于进程间通信（IPC）。
 */
int msgget(key_t key, int msgflg);

/**
 * @brief 接收消息队列中的消息。
 * msgrcv 函数从指定消息队列中接收消息。
 * 
 * @param msqid[in]：消息队列的标识符。
 * @param msgp[out]：指向存储消息的缓冲区。
 * @param msgsz[in]：缓冲区的大小（不包含消息类型的大小）。
 * @param msgtyp[in]：接收消息的类型。
 *  - 正数：接收指定类型的消息。
 *  - 0：接收队列中第一个消息。
 *  - 负数：接收小于等于该绝对值的最小类型的消息。
 * @param msgflg[in]：操作标志。
 *  - IPC_NOWAIT：若无符合条件的消息，则立即返回。
 *  - MSG_NOERROR：截断超过缓冲区大小的消息。
 * 
 * @return
 *  - >= 0：成功，返回接收的字节数。
 *  - -1：失败，`errno` 会设置相应的错误码。
 * 
 * @usage
 *  - 从消息队列中接收消息，用于进程间通信。
 */
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);

/**
 * @brief 向消息队列中发送消息。
 * msgsnd 函数将指定消息发送到目标消息队列。
 * 
 * @param msqid[in]：消息队列的标识符。
 * @param msgp[in]：指向消息的缓冲区。
 * @param msgsz[in]：消息正文的大小（不包含消息类型的大小）。
 * @param msgflg[in]：操作标志。
 *  - IPC_NOWAIT：若队列满，则立即返回。
 * 
 * @return
 *  - 0：成功。
 *  - -1：失败，`errno` 会设置相应的错误码。
 * 
 * @usage
 *  - 将消息发送到消息队列，用于进程间通信。
 */
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
```

## C9:存储管理  
> 不仅包含Storage管理，还包含Memory  
> 程序始终是死的，只是腐烂速度快而已  

* 装入：将已编译的程序装入内存这时候的地址变换称为重映射
    * 动态链接库在此时装入

* ar rcs sample.a sample.o
    1. ar："archive" 的缩写，用于创建、修改和提取静态库文件（也称为归档文件）。在 Linux 和 Unix 系统中，静态库通常以 .a 结尾。
    1. rcs
        * r：插入文件到归档中。如果归档文件不存在，则创建一个新的归档。
        * c：创建归档文件时不显示提示（静默模式）。
        * s：更新归档的索引（symbol table），方便链接器查找符号。
    1. sample.a：目标静态库文件
    1. sample.o：要添加到归档中的目标文件（即已编译的 .o 文件）。
    1. .so：共享对象，可视作动态链接

* 内存分配：
    1. 固定分区：划死
    1. 可变分区
    1. 单一连续分配：用户程序与操作系统和驱动隔离开
    1. 离散分配：使用页式存储
        * 内存地址被划分成页，页的大小固定
        * 地址分为页号和页内偏移
        
## C10：文件管理
> linux万物皆文件  
> 冷知识：wsl2下window盘挂载在/mnt/下，这意味着**sudo rm -rf ./ --no-preserve-root**能干碎宿主机  
> 尽管宿主机这个名字并不恰当
* 无趣概念：
    1. 顺序文件：定长文件
    1. 索引文件：索引号+指针
    1. 文件系统：文件，目录，路径，描述符；存储，命名，访问控制，内容管理，结构管理
        * 常见文件系统：win-NTFS，linux-Ext，openEuler-Ext4
    1. 连续分配，链接分配，索引分配，空闲表/链，位序图
    1. 一致性问题：两个表
* 文件创建：touch创建文件，mkdir创建夹
* 文件编辑：vi/vim
    > i插入，:wq退出保存
* 文件属性：chmod
    * Dict-Read-Write-Excute，拥有者-拥有者所在组-其他人
* proc：虚拟文件系统，把系统内核当作文件进行查询
* 虚拟存储器-页式存储：虚拟内存
    * 最佳置换算法OPT：替换最不可能的页
    * 先进先出FIFO：替换最久的页
    * 最近最久未使用LRU：替换最久没用的页

## C15：死锁
> 应届生找的工作要求5年工作经验  
* 原因：互斥，占有并等待，不抢占，循环等待
* 预防-不会死锁：共享资源，预分配，允许抢占，顺序规则
* 避免-解决死锁：银行家算法-能不能还款
    * 三个矩阵：已分配Allocation，需求Need，资源Resource
* 死锁检测：资源分配图
    * 圆-进程，方框-资源，请求/分配操作-箭头
    * 显然易见的死循环
* 死锁接触：最小代价剥夺资源
    
## C16：调度
* 长程/中程/短程：进程载入/内存管理/cpu
* 算法：
    1. 先来先干First Come First Served
    1. 短作业优先Short Job First
    1. 时间片轮转Round Robin：分配固定时间
    1. 优先调度Priority Scheduling：优先级分配，先来先干
    1. 多级反馈队列Multi-Level Feedback Queue：可变优先级-占用过长会降低优先级
* 性能指标：响应，周转（完成时间），等待
* 策略：抢占/上下文